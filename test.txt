-- ============================================
-- Enhanced OMS Schema with Product Variants
-- Replaces hardcoded sizes/colors with lookup tables
-- ============================================

-- Remove old enum types if they exist
DROP TYPE IF EXISTS size CASCADE;
DROP TYPE IF EXISTS color CASCADE;
DROP TYPE IF EXISTS order_status CASCADE;

-- Order Status Enum
CREATE TYPE order_status AS ENUM ('pending', 'paid', 'processing', 'shipped', 'delivered', 'cancelled');

-- ============================================
-- LOOKUP TABLES FOR VARIANTS
-- ============================================

-- Sizes lookup table
CREATE TABLE IF NOT EXISTS Sizes (
    sizeId UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    sizeName VARCHAR(50) NOT NULL UNIQUE,
    sortOrder INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Colors lookup table
CREATE TABLE IF NOT EXISTS Colors (
    colorId UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    colorName VARCHAR(50) NOT NULL UNIQUE,
    hexCode VARCHAR(7), -- Optional: for displaying color swatches
    created_at TIMESTAMP DEFAULT NOW()
);

-- Categories
CREATE TABLE IF NOT EXISTS Categories (
    categoryId UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Customers with FIFO cycling
CREATE TABLE IF NOT EXISTS Customers (
    customerId UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    customerName VARCHAR(255),
    email VARCHAR(255) UNIQUE NOT NULL,
    phoneNum VARCHAR(20),
    shippingAddress TEXT,
    billingAddress TEXT,
    customerPasswd TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    last_login TIMESTAMP,
    deleted_at TIMESTAMP,
    cycle_position INT,
    is_active BOOLEAN DEFAULT TRUE
);

CREATE INDEX IF NOT EXISTS idx_customers_cycle ON Customers(cycle_position, is_active) WHERE deleted_at IS NULL;

-- ============================================
-- PRODUCTS WITH VARIANT SUPPORT
-- ============================================

-- Base Products (parent/master products)
CREATE TABLE IF NOT EXISTS Products (
    productId UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    basePrice DECIMAL(10,2) NOT NULL,
    categoryName VARCHAR(255),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    deleted_at TIMESTAMP
);

-- Product Variants (SKU level - specific size/color combinations)
CREATE TABLE IF NOT EXISTS ProductVariants (
    variantId UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    productId UUID NOT NULL,
    sizeId UUID,
    colorId UUID,
    sku VARCHAR(100) UNIQUE,
    price DECIMAL(10,2), -- Override base price if needed
    stockQuantity INT DEFAULT 0,
    inStock BOOLEAN GENERATED ALWAYS AS (stockQuantity > 0) STORED,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (productId) REFERENCES Products(productId) ON DELETE CASCADE,
    FOREIGN KEY (sizeId) REFERENCES Sizes(sizeId),
    FOREIGN KEY (colorId) REFERENCES Colors(colorId),
    UNIQUE (productId, sizeId, colorId) -- Prevent duplicate variants
);

CREATE INDEX IF NOT EXISTS idx_variants_product ON ProductVariants(productId);
CREATE INDEX IF NOT EXISTS idx_variants_stock ON ProductVariants(stockQuantity) WHERE stockQuantity > 0;

-- Product-Category junction
CREATE TABLE IF NOT EXISTS ProductCategories (
    productId UUID NOT NULL,
    categoryId UUID NOT NULL,
    PRIMARY KEY (productId, categoryId),
    FOREIGN KEY (productId) REFERENCES Products(productId) ON DELETE CASCADE,
    FOREIGN KEY (categoryId) REFERENCES Categories(categoryId) ON DELETE CASCADE
);

-- Product Images
CREATE TABLE IF NOT EXISTS Images (
    imageId UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    productId UUID NOT NULL,
    colorId UUID, -- Optional: associate image with specific color
    url TEXT NOT NULL,
    displayOrder INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (productId) REFERENCES Products(productId) ON DELETE CASCADE,
    FOREIGN KEY (colorId) REFERENCES Colors(colorId)
);

-- Payment Methods
CREATE TABLE IF NOT EXISTS PaymentMethods (
    paymentMethodId UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    customerId UUID NOT NULL,
    cardholderName VARCHAR(255),
    last4Digits VARCHAR(4),
    cardBrand VARCHAR(50),
    expirationDate DATE,
    created_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (customerId) REFERENCES Customers(customerId)
);

-- Orders
CREATE TABLE IF NOT EXISTS Orders (
    orderId UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    customerId UUID NOT NULL,
    orderTimestamp TIMESTAMP DEFAULT NOW(),
    status order_status DEFAULT 'pending',
    subtotal DECIMAL(10,2) NOT NULL,
    shippingCost DECIMAL(10,2) DEFAULT 0,
    totalAmount DECIMAL(10,2) NOT NULL,
    shippingAddress TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (customerId) REFERENCES Customers(customerId)
);

-- Order Items - now references variants
CREATE TABLE IF NOT EXISTS OrderItems (
    orderItemId UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    orderId UUID NOT NULL,
    variantId UUID NOT NULL,
    productName VARCHAR(255),
    sizeName VARCHAR(50),
    colorName VARCHAR(50),
    quantity INT NOT NULL CHECK (quantity > 0),
    unitPrice DECIMAL(10,2) NOT NULL,
    subtotal DECIMAL(10,2) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (orderId) REFERENCES Orders(orderId) ON DELETE CASCADE,
    FOREIGN KEY (variantId) REFERENCES ProductVariants(variantId)
);

-- ============================================
-- SEED DATA FOR VARIANTS
-- ============================================

-- Insert standard sizes
INSERT INTO Sizes (sizeName, sortOrder) VALUES
    ('XS', 1),
    ('S', 2),
    ('M', 3),
    ('L', 4),
    ('XL', 5),
    ('XXL', 6),
    ('One Size', 7)
ON CONFLICT (sizeName) DO NOTHING;

-- Insert standard colors with hex codes
INSERT INTO Colors (colorName, hexCode) VALUES
    ('Black', '#000000'),
    ('White', '#FFFFFF'),
    ('Gray', '#808080'),
    ('Grey', '#808080'),
    ('Navy', '#000080'),
    ('Red', '#FF0000'),
    ('Cream', '#FFFDD0'),
    ('Natural', '#F5F5DC')
ON CONFLICT (colorName) DO NOTHING;

-- ============================================
-- ENHANCED FUNCTIONS
-- ============================================

DROP FUNCTION IF EXISTS get_products_with_variants();

CREATE OR REPLACE FUNCTION get_products_with_variants()
RETURNS TABLE (
  productid uuid,
  name varchar,
  description text,
  baseprice numeric,
  categories text[],
  images text[],
  available_sizes jsonb,
  available_colors jsonb,
  variants jsonb,
  in_stock boolean
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    p.productid,
    p.name,
    p.description,
    p.baseprice,
    ARRAY_AGG(DISTINCT c.name) FILTER (WHERE c.name IS NOT NULL) as categories,
    ARRAY_AGG(DISTINCT i.url ORDER BY i.displayorder) FILTER (WHERE i.url IS NOT NULL) as images,
    
    -- Fixed: Available sizes as JSON array
    (SELECT jsonb_agg(size_obj ORDER BY size_name)
     FROM (
       SELECT DISTINCT ON (s.sizeid)
         jsonb_build_object('id', s.sizeid, 'name', s.sizename) as size_obj,
         s.sizename as size_name
       FROM productvariants pv
       JOIN sizes s ON pv.sizeid = s.sizeid
       WHERE pv.productid = p.productid AND pv.stockquantity > 0
     ) sizes_subq) as available_sizes,
    
    -- Fixed: Available colors as JSON array
    (SELECT jsonb_agg(color_obj ORDER BY color_name)
     FROM (
       SELECT DISTINCT ON (co.colorid)
         jsonb_build_object('id', co.colorid, 'name', co.colorname, 'hex', co.hexcode) as color_obj,
         co.colorname as color_name
       FROM productvariants pv
       JOIN colors co ON pv.colorid = co.colorid
       WHERE pv.productid = p.productid AND pv.stockquantity > 0
     ) colors_subq) as available_colors,
    
    -- All variants with stock info
    (SELECT jsonb_agg(
      jsonb_build_object(
        'variantId', pv.variantid,
        'sku', pv.sku,
        'size', s.sizename,
        'color', co.colorname,
        'price', COALESCE(pv.price, p.baseprice),
        'stock', pv.stockquantity,
        'inStock', pv.instock
      ) ORDER BY s.sortorder, co.colorname
    )
     FROM productvariants pv
     LEFT JOIN sizes s ON pv.sizeid = s.sizeid
     LEFT JOIN colors co ON pv.colorid = co.colorid
     WHERE pv.productid = p.productid) as variants,
    
    -- Product is in stock if any variant has stock
    EXISTS(
      SELECT 1 FROM productvariants pv2 
      WHERE pv2.productid = p.productid AND pv2.stockquantity > 0
    ) as in_stock
    
  FROM products p
  LEFT JOIN productcategories pc ON p.productid = pc.productid
  LEFT JOIN categories c ON pc.categoryid = c.categoryid
  LEFT JOIN images i ON p.productid = i.productid
  WHERE p.deleted_at IS NULL
  GROUP BY p.productid;
END;
$$;
-- Create order with variant support
CREATE OR REPLACE FUNCTION create_order_with_variants(
  p_customerid uuid,
  p_items jsonb,
  p_shipping_address text,
  p_shipping_cost numeric DEFAULT 0
) RETURNS uuid
LANGUAGE plpgsql
AS $$
DECLARE
  new_orderid uuid;
  subtotal_amt numeric := 0;
  total_amt numeric;
  item jsonb;
  prod_name varchar;
  size_name varchar;
  color_name varchar;
  variant_price numeric;
BEGIN
  -- Calculate subtotal
  FOR item IN SELECT * FROM jsonb_array_elements(p_items)
  LOOP
    SELECT COALESCE(pv.price, p.baseprice)
    INTO variant_price
    FROM productvariants pv
    JOIN products p ON pv.productid = p.productid
    WHERE pv.variantid = (item->>''variantId'')::uuid;
    
    subtotal_amt := subtotal_amt + ((item->>''quantity'')::int * variant_price);
  END LOOP;
  
  total_amt := subtotal_amt + p_shipping_cost;
  
  -- Create order
  INSERT INTO orders (
    customerid, subtotal, shippingcost, totalamount, 
    shippingaddress, status
  )
  VALUES (
    p_customerid, subtotal_amt, p_shipping_cost, total_amt,
    p_shipping_address, ''pending''
  )
  RETURNING orderid INTO new_orderid;
  
  -- Insert order items
  FOR item IN SELECT * FROM jsonb_array_elements(p_items)
  LOOP
    SELECT p.name, s.sizename, co.colorname, COALESCE(pv.price, p.baseprice)
    INTO prod_name, size_name, color_name, variant_price
    FROM productvariants pv
    JOIN products p ON pv.productid = p.productid
    LEFT JOIN sizes s ON pv.sizeid = s.sizeid
    LEFT JOIN colors co ON pv.colorid = co.colorid
    WHERE pv.variantid = (item->>''variantId'')::uuid;
    
    INSERT INTO orderitems (
      orderid, variantid, productname, sizename, colorname, 
      quantity, unitprice, subtotal
    )
    VALUES (
      new_orderid,
      (item->>''variantId'')::uuid,
      prod_name,
      size_name,
      color_name,
      (item->>''quantity'')::int,
      variant_price,
      ((item->>''quantity'')::int * variant_price)
    );
    
    -- Update stock
    UPDATE productvariants 
    SET stockquantity = stockquantity - (item->>''quantity'')::int
    WHERE variantid = (item->>''variantId'')::uuid;
  END LOOP;
  
  RETURN new_orderid;
END;
$$;

-- Get order receipt with variant details
CREATE OR REPLACE FUNCTION get_order_receipt(p_orderid uuid)
RETURNS TABLE (
  orderid uuid,
  ordertimestamp timestamp,
  status order_status,
  customername varchar,
  customeremail varchar,
  shippingaddress text,
  subtotal numeric,
  shippingcost numeric,
  totalamount numeric
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    o.orderid,
    o.ordertimestamp,
    o.status,
    c.customername,
    c.email,
    o.shippingaddress,
    o.subtotal,
    o.shippingcost,
    o.totalamount
  FROM orders o
  JOIN customers c ON o.customerid = c.customerid
  WHERE o.orderid = p_orderid;
END;
$$;

-- Get order items with variant details
CREATE OR REPLACE FUNCTION get_order_items_with_variants(p_orderid uuid)
RETURNS TABLE (
  productname varchar,
  sizename varchar,
  colorname varchar,
  quantity int,
  unitprice numeric,
  subtotal numeric
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    oi.productname,
    oi.sizename,
    oi.colorname,
    oi.quantity,
    oi.unitprice,
    oi.subtotal
  FROM orderitems oi
  WHERE oi.orderid = p_orderid;
END;
$$;

-- Customer cycling functions (unchanged)
CREATE OR REPLACE FUNCTION add_customer_with_cycling(
  p_email varchar,
  p_customerpasswd text,
  p_customername varchar DEFAULT NULL,
  p_phonenum varchar DEFAULT NULL,
  p_shippingaddress text DEFAULT NULL,
  p_billingaddress text DEFAULT NULL
) RETURNS uuid
LANGUAGE plpgsql
AS $$
DECLARE
  new_customer_id uuid;
  current_count int;
  oldest_customer_id uuid;
BEGIN
  SELECT COUNT(*) INTO current_count 
  FROM customers 
  WHERE is_active = TRUE AND deleted_at IS NULL;
  
  IF current_count >= 10 THEN
    SELECT customerid INTO oldest_customer_id
    FROM customers
    WHERE is_active = TRUE AND deleted_at IS NULL
    ORDER BY cycle_position ASC
    LIMIT 1;
    
    UPDATE customers SET is_active = FALSE, deleted_at = NOW() 
    WHERE customerid = oldest_customer_id;
    
    UPDATE customers 
    SET cycle_position = cycle_position - 1
    WHERE is_active = TRUE AND deleted_at IS NULL;
  END IF;
  
  INSERT INTO customers (
    email, customerpasswd, customername, phonenum, 
    shippingaddress, billingaddress, cycle_position, is_active
  )
  VALUES (
    p_email, p_customerpasswd, p_customername, p_phonenum,
    p_shippingaddress, p_billingaddress,
    LEAST(current_count + 1, 10), TRUE
  )
  RETURNING customerid INTO new_customer_id;
  
  RETURN new_customer_id;
END;
$$;

CREATE OR REPLACE FUNCTION update_order_status(
  p_orderid uuid,
  p_status order_status
) RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  UPDATE orders 
  SET status = p_status, updated_at = NOW()
  WHERE orderid = p_orderid;
END;
$$;